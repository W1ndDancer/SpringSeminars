# Всем привет с семинара по основам системы контроля версий Git!

Сюда вы будете отправлять свои запросы в качестве домашней работы. Всем успехов :)

На сайте GB вы должны будете прикрепить скрин вашего экрана с выполненным pull request'ом.


# РУКОВОДСТВО ПО GIT

Перед тем как начать, немного общих интересных сведений о Git-е и вообще зачем это чудо). Благо пишу я это не сам, но магический command+C и command+V меня спасатет. Мухахаха!

Git — это набор консольных утилит, которые отслеживают и фиксируют изменения в файлах (чаще всего речь идет об исходном коде программ, но вы можете использовать его для любых файлов на ваш вкус). Изначально Git был создан Линусом Торвальдсом при разработке ядра Linux. Однако инструмент так понравился разработчикам, что в последствии, он получил широкое распространение и его стали использовать в других проектах. С его помощью вы можете сравнивать, анализировать, редактировать, сливать изменения и возвращаться назад к последнему сохранению. Этот процесс называется контролем версий.

Для чего он нужен? Ну во-первых, чтобы отследить изменения, произошедшие с проектом, со временем. Проще говоря, мы можем посмотреть как менялись файлы программы, на всех этапах разработки и при необходимости вернуться назад и что-то отредактировать. Часто бывают ситуации, когда, во вполне себе работающий код, вам нужно внести определенные правки или улучшить какой-то функционал, по желанию заказчика. Однако после внедрения нововведений, вы с ужасом понимаете, что все сломалось. У вас начинается судорожно дергаться глаз, а в воздухе повисает немой вопрос: “Что делать?” Без системы контроля версий, вам надо было бы долго напряженно просматривать код, чтобы понять как было до того, как все перестало работать. С Гитом же, все что нужно сделать - это откатиться на коммит назад.

Во-вторых он чрезвычайно полезен при одновременной работе нескольких специалистов, над одним проектом. Без Гита случится коллапс, когда разработчики, скопировав весь код из главной папки и сделав с ним задуманное, попытаются одновременно вернуть весь код обратно.
Git является распределенным, то есть не зависит от одного центрального сервера, на котором хранятся файлы. Вместо этого он работает полностью локально, сохраняя данные в директориях на жестком диске, которые называются репозиторием. Тем не менее, вы можете хранить копию репозитория онлайн, это сильно облегчает работу над одним проектом для нескольких людей. Для этого используются сайты вроде github.

---
## Установка и настройка Git на Mac
---

- Установка  
Чтоб установить Git на Mac просто необходимо запустить терминал и "позвать" Git. Например командой *$ git --status*. И если у вас у вас на ноутбуке Git не установлен система автоматически вам предложит установить последнюю версию Git-а.  
Если Вы хотите получить более актуальную версию, то можете воспользоваться бинарным установщиком. Установщик Git для OS X доступен для скачивания с сайта [Git](https://git-scm.com/download/mac)

- Настройка  
    1. После установки необходимо «представиться» системе контроля версий. Это нужно сделать всего один раз, и git запомнит вас. Для этого нужно ввести в терминале 2 команды:  
*git config --global user.name «Ваше имя англ буквами»*  
*git config --global user.email ваша_почта@example.com*  
Данные не проверяются, то есть вы можете указать любую почту и тем более любое имя. Но лучше написать реальные данные. Эти данные будут указываться, когда вы будете делать изменения в файлах, над которыми работаете, а указание реальных данных упростит командную работу.
    2. Git хранит свои файлы и историю прямо в папке проекта. Чтобы создать новый репозиторий, нам нужно открыть терминал, зайти в папку нашего проекта и выполнить команду *git init*. Это включит приложение в этой конкретной папке и создаст скрытую директорию .git, где будет храниться история репозитория и настройки.

Впринципе, это все настройки Git-а, которые необходимы, но если Вы хотите посмотреть все настройки системы то вызовите в терминале команду *git config --list*.

Так же для удобства работы с git-ом можно включить выделение цветом некоторых команд git-а. Для этого в терминале пропишите:  
*git config --global color.ui true  
git config --global color.status auto  
git config --global color.branch auto*

---
## Основные команды
---

Ниже список основных команд Git-а и краткое их описание:
+ *git status* – показывает информацию о текущем состоянии репозитория: актуальна ли информация на нём, нет ли чего-то нового, что поменялось, и так далее.
+ *git add FileName* – Git работает согласно концепции области подготовленных файлов. Команда add подгатавливает файлы (или части файлов, или даже одиночные строчки) к последующему сохранению. Если в файлов в папке, которые необходимо сохранить(зафиксировать), много то можно использовать команду *git add -A* (или *git add .*) .
+ *git reset* – Команда сбрасывает все подготовленные файлы к записи(фиксации). Команда будет полезна если вы случайно подготовили к сохранению(фиксации) лишнее файлы.
+ *git commit -m"Massege"* – Собствено команда commit сохраняет изменения в Git. Один маленький ньюанс: пользователи Git-а эти сохранения(фиксации) называют коммитом(в пер с англ commit = фиксировать) и в жизни ни один человек не говорит: "Ты зафиксировал(сохранил) файл в гите?", а говорят: "Ты закоммитил файл?" и тд. Так что не пугайтесь)
+ *git log* – Выводит журнал наших коммитов, где мы можем посмотреть основную информацию о коммитах. Добавление к команде флажка *--graph* выведет еще и графическое отображение журнала, что полезно при работе с ветками(об этом позже).
+ *git diff* – показывает нам разницу между текущим и последним закоммиченым файлами.
+ *git branch -M main* - изменит название нашей главной ветки на main, вместо этого названия можно использовать любое другое.
---
## Работа с ветками
---

Во время разработки новой функциональности считается хорошей практикой работать с копией оригинального проекта, которую называют веткой. Ветви имеют свою собственную историю и изолированные друг от друга изменения до тех пор, пока вы не решаете слить изменения вместе. Это происходит по набору причин:
+ Уже рабочая, стабильная версия кода сохраняется.
+ Различные новые функции могут разрабатываться параллельно разными программистами.
+ Разработчики могут работать с собственными ветками без риска, что кодовая база поменяется из-за чужих изменений.
+ В случае сомнений, различные реализации одной и той же идеи могут быть разработаны в разных ветках и затем сравниваться.

По аналогии с предыдущим разделом ниже будет список самых необходимых команд для работы с ветками:

+ *git branch* – Выводит список всех веток. По умолчанию есть только одна ветка Master.
+ *git branch BranchName* – Создает новую ветку.
+*git merge BranchName* – Обьеденяет ДВЕ ветки, ту в в которой находитесь и ту которую указали данной командой.
+ *git branch -d(-D) BranchName* – удаляет ветку. Разница межжду двумя флажками в то что, то флажок -D удаляет ветку "без лищних вопросов" и несмотря на возможные ошибки и последующие поломки. При использовани флажка -d ветка удалится только при отстутсвии конфликтов и ошибок, иначе система попросит их разрешить. 
+ *git checkout BranchName* – С помощью этой команды мы можем перемещаться между ветками и коммитами. Чтоб перейти в главную папку пишем : *git checkout Master*, а чтоб переключится на какой либо коммит необходимо вместо *BranchName* написать имя коммита, можно не полностью(не менее 4х символов необходимо)

---
## Конфликты при слиянии
---

При отмене старых коммитов нужно быть готовым к тому, что возникнут конфликты. Такое случается, если файл был изменен еще одним, более новым коммитом. И теперь Git не может найти строчки, состояние которых нужно откатить, так как они больше не существуют.

Помимо сценария, описанного в предыдущем пункте, конфликты регулярно возникают при слиянии ветвей или при отправке чужого кода. Иногда конфликты исправляются автоматически, но обычно с этим приходится разбираться вручную — решать, какой код остается, а какой нужно удалить.
Вот мои свеженькие примеры:

+ Первый пример, назовем его "Дитя неожиданности". В результате слияния двух веток, слияние произошло, но Git нашел некий swap файл который ему мешал. И собственно Git спрашивал что он должен с эти делать. Так как я не знал что это такое за файл и с чем его едят, я просто вышел из изменений и ничего с тем swap файлом не делал и закоммитил изменения и вуаля. Готово.
![here is supose to be an example. We are sorry](1st_example.png)
+ Второй пример, или когда все идет по плану))) В результате того что в изначальном коммите в ветке мастер не было никаких изменений, а были только прописанны подзаголовки, а во время редактирования ветки InstallingNSettingGit я намеренно добавил изменения в базовую информацию то возник конфликт. И Git меня любезно по спросил что ему делать, в данном случае я оставил только текущие изменения и удалил входящие.
![here is supose to be a 2nd example. We are sorry](2nd_example.png)

---
## Работа с удаленными репозиториями
---

До сих пор мы с вами говорили только о работе с локальными файлами, т.е. с теми которые расположены на нашем ноутбуке. И несмотря на то, что сам по себе локальный репозиторий полезен, в большинстве случаев мы хотим поделиться нашей работой или доставить код на сервер, где он будет выполняться.

### Удаленный репозиторий это
репозиторий, хранящийся в облаке, на стороннем сервисе, специально созданном для работы с git и такой репозиторий имеет ряд преимуществ. Во-первых - это своего рода резервная копия вашего проекта, предоставляющая возможность безболезненной работы в команде. А еще в таком репозитории можно пользоваться дополнительными возможностями хостинга. К примеру - визуализацией истории или возможностью разрабатывать вашу программу непосредственно в веб-интерфейсе.

### Основные команды

+ *git clone Link* – с помощью этой команды вы копируете удаленный репозиторий к себе на локальный ПК, где *Link* ссылка на наш удаленный репозиторий. При этом вы переносите себе все файлы и папки проекта, а также всю его историю с момента его создания. При клонировании в текущий каталог, там будет создана папка, в которую поместятся все проектные файлы и скрытая директория .git, с самим репозиторием, или с необходимой информацией о нем. В такой ситуации, для клонируемого репозитория, по умолчанию, будет создана папка с одноименным названием, но его можно залить и в другую директорию.
+ *git remote add origin Link* – чтобы загрузить что-нибудь в удаленный репозиторий, сначала нужно к нему подключиться и данная команда связывает наш локальный репозиторий с удаленным репозиторием. И конечно перед тем как связывать репозитории нужно сначала зарегестрироваться на сервисе-облаке где будут храниться данные. Самы популярный их таких сервисов это GitHub. Регистрация и установка может занять время, но все подобные сервисы предоставляют хорошую и понятную инструкцию.
+ *git git push origin main* – Это команда пересылает наши изменения из главной ветки на сервер. *Origin* - название  удаленного репозитория, а *Main* - название главной ветки. Однако пушить надо осторожно, ведь рассматриваемая команда перезаписывает безвозвратно все изменения. В большинстве случаев, ее используют, чтобы опубликовать выгружаемые локальные изменения в центральный репозиторий. А еще ее применяют для того, чтобы поделиться, внесенными в локальный репозиторий, нововведениями, с коллегами или другими удаленными участниками разработки проекта. При первом пуше вам скорее всего нужно будет авторизоваться на сервисе, чтобы он вас запомнил в последствии этого делать будет не нужно. Так же после первого пуша можно использовать сокращенную команду *git push*
+ *git fetch* – Команда git fetch загружает коммиты, файлы и ссылки из удаленного репозитория в ваш локальный репозиторий. Извлеките данные с помощью команды fetch, если хотите увидеть, над чем работают остальные. Эта команда позволяет увидеть прогресс в центральном репозитории, но при этом не вынуждает вас выполнять слияние изменений с вашим репозиторием. Извлеченное содержимое в Git остается изолированным от имеющихся локальных данных и совершенно не влияет на локальную разработку. Чтобы переключиться на извлеченное содержимое, нужно отдельно запустить команду git checkout. Таким образом, применение команды fetch позволяет безопасно просмотреть коммиты, перед тем как интегрировать их в локальный репозиторий.
+ *git pull* – Загрузить содержимое из удаленного репозитория можно с помощью двух команд: git pull и git fetch. Из этих двух команд git fetch можно считать «безопасным» вариантом. Она загружает удаленное содержимое, но не обновляет рабочее состояние локального репозитория, оставляя текущую работу нетронутой. Команда git pull действует более агрессивно: она загружает удаленное содержимое для активной локальной ветки и сразу выполняет команду git merge, создавая коммит слияния для нового удаленного содержимого. Если у вас есть ожидающие изменения, то возникнут конфликты, и будет запущен процесс разрешения конфликтов слияния.
